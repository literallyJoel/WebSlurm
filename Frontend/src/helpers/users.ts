import { apiEndpoint } from "@/config/config";
import crypto from "crypto-js";
import { TokenData } from "./auth";
import { jwtDecode } from "jwt-decode";

export type CreateAccountRequest = {
  name: string;
  email: string;
  role: number;
  generatedPass: boolean;
  password?: string;
};

export type CreateAccountResponse = {
  userId: string;
  generatedPass?: string;
};

export type UpdateAccountRequest = {
  name: string;
  email: string;
  role: number;
  requiresPasswordReset?: boolean;
  password?: string;
};

export type User = {
  userId: string;
  userName: string;
  userEmail: string;
  role: number;
};

//=====Autogenerated Password=====//
export async function createAccount(
  name: string,
  email: string,
  role: number,
  token: string,
  generatePass: true
): Promise<CreateAccountResponse>;
//=======Password Provided========//
export async function createAccount(
  name: string,
  email: string,
  role: number,
  token: string,
  generatePass: false,
  password: string
): Promise<CreateAccountResponse>;
//=======Function Definition======//
export async function createAccount(
  name: string,
  email: string,
  role: number,
  token: string,
  generatePass: boolean,
  password?: string
): Promise<CreateAccountResponse> {
  if (generatePass === true) {
    const response = await fetch(apiEndpoint + "/users/", {
      method: "POST",
      body: JSON.stringify({
        name: name,
        email: email,
        role: role,
        generatePass: true,
      }),
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });
    if (!response.ok) {
      return Promise.reject(new Error(response.statusText));
    }
    return await response.json();
  } else {
    /*
          We non-null coerce pasword here because the type
          definition of the function means if generatePass is false
          password must be defined, but TS doesn't pick this up.
          We hash on the server-side also, we just do so here so that
          the server never sees the users actual password.
    */
    const hashedPass = crypto.SHA512(password!).toString();
    const response = await fetch(apiEndpoint + "/users/", {
      method: "POST",
      body: JSON.stringify({
        name: name,
        email: email,
        role: role,
        password: hashedPass,
        generatePass: false,
      }),
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });
    if (!response.ok) {
      return Promise.reject(new Error(response.statusText));
    }
    return await response.json();
  }
}

export const updateAccount = async (
  account: UpdateAccountRequest,
  token: string,
  userId?: string
): Promise<Response> => {
  if (account.password) {
    account.password = crypto.SHA512(account.password).toString();
  }
  const endpoint = userId
    ? `${apiEndpoint}/users/${userId}`
    : `${apiEndpoint}/users`;
  const response = await fetch(endpoint, {
    method: "PUT",
    headers: { Authorization: `Bearer ${token}` },
    body: JSON.stringify(account),
  });

  if (!response.ok) {
    return Promise.reject(new Error(response.statusText));
  }
  return await response;
};

export const deleteAccount = async (
  token: string,
  userId?: string
): Promise<Response> => {
  const endpoint = userId
    ? `${apiEndpoint}/users/${userId}`
    : `${apiEndpoint}/users`;

  const response = await fetch(endpoint, {
    method: "DELETE",
    headers: { Authorization: `Bearer ${token}` },
  });

  if (!response.ok) {
    return Promise.reject(new Error(response.statusText));
  }

  return await response;
};

export const getAllUsers = async (token: string): Promise<User[]> => {
  const response = await fetch(`${apiEndpoint}/users`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  if (!response.ok) {
    return Promise.reject(new Error(response.statusText));
  }

  const users = await response.json();
  return Array.isArray(users) ? users : [users];
};

export const getUserCount = async (
  token: string
): Promise<{ count: number }> => {
  const response = await fetch(`${apiEndpoint}/users/count`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  if (!response.ok) {
    return Promise.reject(new Error(response.statusText));
  }

  return await response.json();
};

export const decodeToken = (token: string): TokenData => {
  return jwtDecode(token);
};

export const validateEmail = (email: string): boolean => {
  return /[^\s@]+@[^\s@]+\.[^\s@]+/g.test(email);
};

export const validateName = (name: string) => {
  //Hard to validate names, so we just ensure something is in there
  return name.length !== 0;
};

export const validatePassword = (password: string) => {
  //Ensures password is at least 8 characters, contains a letter, a numer, and a special char.
  return /^(?=.*[A-Z])(?=.*\d)(?=.*[^A-Za-z\d]).{8,}$/.test(password);
};

export const makeUserAdmin = async (
  token: string,
  userId: string
): Promise<Response> => {
  const response = await fetch(`${apiEndpoint}/users/role`, {
    method: "PUT",
    headers: { Authorization: `Bearer ${token}` },
    body: JSON.stringify({ userId: userId, role: 1 }),
  });

  if (!response.ok) {
    return Promise.reject(new Error(response.statusText));
  }

  return response;
};

export const removeUserAdmin = async (
  token: string,
  userId: string
): Promise<Response> => {
  const response = await fetch(`${apiEndpoint}/users/role`, {
    method: "PUT",
    headers: { Authorization: `Bearer ${token}` },
    body: JSON.stringify({ userId: userId, role: 0 }),
  });

  if (!response.ok) {
    return Promise.reject(new Error(response.statusText));
  }

  return response;
};

export const resetUserPassword = async (
  token: string,
  userId: string
): Promise<Response> => {
  const response = await fetch(`${apiEndpoint}/users/reset`, {
    method: "POST",
    headers: { Authorization: `Bearer ${token}` },
    body: JSON.stringify({ userId: userId }),
  });

  if (!response.ok) {
    return Promise.reject(new Error(response.statusText));
  }

  return response;
};

export const selfServiceReset = async (
  userEmail: string
): Promise<Response> => {
  const response = await fetch(`${apiEndpoint}/users/reset/self`, {
    method: "POST",
    body: JSON.stringify({ userEmail }),
  });

  if (!response.ok) {
    return Promise.reject(new Error(response.statusText));
  }

  return response;
};
